/* ex: set ro ft=c: -*- buffer-read-only:t -*-
 * !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
 *
 * This file is generated automatically from './src/pmc/callcontext.pmc'
 * by tools/build/pmc2c.pl.
 *
 * Any changes made here will be lost!
 *
 */

/* HEADERIZER HFILE: none */
/* HEADERIZER STOP */

#include "parrot/parrot.h"
#include "parrot/extend.h"
#include "parrot/dynext.h"
#include "pmc_fixedintegerarray.h"
#include "pmc_callcontext.h"
#include "pmc_default.h"
#include "callcontext.str"
#include "pmc_continuation.h"
#include "pmc_callcontext.h"
#line 1 "./src/pmc/callcontext.pmc"
/*
Copyright (C) 2008-2014, Parrot Foundation.

=head1 NAME

src/pmc/callcontext.pmc - CallContext PMC

=head1 DESCRIPTION

The CallContext PMC is used to store the argument list and argument meta
information for a multiple dispatch call.

=head2 Functions

=over 4

=cut

*/

typedef struct Pcc_cell
{
    union u {
        PMC     *p;
        STRING  *s;
        INTVAL   i;
        FLOATVAL n;
    } u;
    INTVAL type;
} Pcc_cell;

#define NOCELL     0
#define INTCELL    1
#define FLOATCELL  2
#define STRINGCELL 3
#define PMCCELL    4

#define ALLOC_CELL(i) \
    (Pcc_cell *)Parrot_gc_allocate_fixed_size_storage((i), sizeof (Pcc_cell))

#define FREE_CELL(i, c) \
    Parrot_gc_free_fixed_size_storage((i), sizeof (Pcc_cell), (c))

#define CLONE_CELL(i, c, c_new) do { \
    (c_new)  = ALLOC_CELL(i); \
    *(c_new) = *(c); \
} while (0)

#define CELL_TYPE_MASK(c) (c)->type

#define CELL_INT(c)     (c)->u.i
#define CELL_FLOAT(c)   (c)->u.n
#define CELL_STRING(c)  (c)->u.s
#define CELL_PMC(c)     (c)->u.p

#define HLL_TYPE(i) Parrot_hll_get_ctx_HLL_type(interp, (i))

/* HEADERIZER HFILE: none */
/* HEADERIZER BEGIN: static */
/* Don't modify between HEADERIZER BEGIN / HEADERIZER END.  Your changes will be lost. */

static FLOATVAL autobox_floatval(PARROT_INTERP, ARGIN(const Pcc_cell *cell))
        __attribute__nonnull__(1)
        __attribute__nonnull__(2);

static INTVAL autobox_intval(PARROT_INTERP, ARGIN(const Pcc_cell *cell))
        __attribute__nonnull__(1)
        __attribute__nonnull__(2);

PARROT_CANNOT_RETURN_NULL
static PMC * autobox_pmc(PARROT_INTERP, ARGIN(Pcc_cell *cell), INTVAL type)
        __attribute__nonnull__(1)
        __attribute__nonnull__(2);

PARROT_CANNOT_RETURN_NULL
static STRING * autobox_string(PARROT_INTERP, ARGIN(const Pcc_cell *cell))
        __attribute__nonnull__(1)
        __attribute__nonnull__(2);

static void ensure_positionals_storage(PARROT_INTERP,
    ARGIN(PMC *self),
    INTVAL size)
        __attribute__nonnull__(1)
        __attribute__nonnull__(2);

static void ensure_positionals_storage_ap(PARROT_INTERP,
    ARGIN(PMC *self),
    INTVAL size,
    INTVAL allocated_positionals)
        __attribute__nonnull__(1)
        __attribute__nonnull__(2);

PARROT_CANNOT_RETURN_NULL
static Pcc_cell* get_cell_at(PARROT_INTERP, ARGIN(PMC *self), INTVAL key)
        __attribute__nonnull__(1)
        __attribute__nonnull__(2);

PARROT_CANNOT_RETURN_NULL
static Hash * get_hash(PARROT_INTERP, ARGIN(PMC *SELF))
        __attribute__nonnull__(1)
        __attribute__nonnull__(2);

PARROT_CAN_RETURN_NULL
static PMC * get_named_names(PARROT_INTERP, ARGIN(PMC *SELF))
        __attribute__nonnull__(1)
        __attribute__nonnull__(2);

static void mark_cell(PARROT_INTERP, ARGIN(Pcc_cell *c))
        __attribute__nonnull__(1)
        __attribute__nonnull__(2);

static void mark_hash(PARROT_INTERP, ARGIN(Hash *h))
        __attribute__nonnull__(1)
        __attribute__nonnull__(2);

static void mark_positionals(PARROT_INTERP, ARGIN(PMC *self))
        __attribute__nonnull__(1)
        __attribute__nonnull__(2);

#define ASSERT_ARGS_autobox_floatval __attribute__unused__ int _ASSERT_ARGS_CHECK = (\
       PARROT_ASSERT_ARG(interp) \
    , PARROT_ASSERT_ARG(cell))
#define ASSERT_ARGS_autobox_intval __attribute__unused__ int _ASSERT_ARGS_CHECK = (\
       PARROT_ASSERT_ARG(interp) \
    , PARROT_ASSERT_ARG(cell))
#define ASSERT_ARGS_autobox_pmc __attribute__unused__ int _ASSERT_ARGS_CHECK = (\
       PARROT_ASSERT_ARG(interp) \
    , PARROT_ASSERT_ARG(cell))
#define ASSERT_ARGS_autobox_string __attribute__unused__ int _ASSERT_ARGS_CHECK = (\
       PARROT_ASSERT_ARG(interp) \
    , PARROT_ASSERT_ARG(cell))
#define ASSERT_ARGS_ensure_positionals_storage __attribute__unused__ int _ASSERT_ARGS_CHECK = (\
       PARROT_ASSERT_ARG(interp) \
    , PARROT_ASSERT_ARG(self))
#define ASSERT_ARGS_ensure_positionals_storage_ap __attribute__unused__ int _ASSERT_ARGS_CHECK = (\
       PARROT_ASSERT_ARG(interp) \
    , PARROT_ASSERT_ARG(self))
#define ASSERT_ARGS_get_cell_at __attribute__unused__ int _ASSERT_ARGS_CHECK = (\
       PARROT_ASSERT_ARG(interp) \
    , PARROT_ASSERT_ARG(self))
#define ASSERT_ARGS_get_hash __attribute__unused__ int _ASSERT_ARGS_CHECK = (\
       PARROT_ASSERT_ARG(interp) \
    , PARROT_ASSERT_ARG(SELF))
#define ASSERT_ARGS_get_named_names __attribute__unused__ int _ASSERT_ARGS_CHECK = (\
       PARROT_ASSERT_ARG(interp) \
    , PARROT_ASSERT_ARG(SELF))
#define ASSERT_ARGS_mark_cell __attribute__unused__ int _ASSERT_ARGS_CHECK = (\
       PARROT_ASSERT_ARG(interp) \
    , PARROT_ASSERT_ARG(c))
#define ASSERT_ARGS_mark_hash __attribute__unused__ int _ASSERT_ARGS_CHECK = (\
       PARROT_ASSERT_ARG(interp) \
    , PARROT_ASSERT_ARG(h))
#define ASSERT_ARGS_mark_positionals __attribute__unused__ int _ASSERT_ARGS_CHECK = (\
       PARROT_ASSERT_ARG(interp) \
    , PARROT_ASSERT_ARG(self))
/* Don't modify between HEADERIZER BEGIN / HEADERIZER END.  Your changes will be lost. */
/* HEADERIZER END: static */

/*

=item C<static void ensure_positionals_storage(PARROT_INTERP, PMC *self, INTVAL
size)>

Ensure that C<self> has enough storage space for C<size> positionals.

=cut

*/

static void
ensure_positionals_storage(PARROT_INTERP, ARGIN(PMC *self), INTVAL size)
{
    ASSERT_ARGS(ensure_positionals_storage)
    INTVAL allocated_positionals;

    GETATTR_CallContext_allocated_positionals(interp, self, allocated_positionals);

    if (size <= allocated_positionals)
        return;

    ensure_positionals_storage_ap(interp, self, size, allocated_positionals);
}

/*

=item C<static void ensure_positionals_storage_ap(PARROT_INTERP, PMC *self,
INTVAL size, INTVAL allocated_positionals)>

Allocate a new chunk of memory that can contain C<allocated_positionals>
entries, either from the fixed size allocator or from system memory, and free
the the old chunk (if needed).

=cut

*/

static void
ensure_positionals_storage_ap(PARROT_INTERP,
                              ARGIN(PMC *self), INTVAL size, INTVAL allocated_positionals)
{
    ASSERT_ARGS(ensure_positionals_storage_ap)
    INTVAL num_positionals;
    Pcc_cell *array, *new_array;

    if (size < 8)
        size = 8;

    if (size > 8)
        new_array = (Pcc_cell *)Parrot_gc_allocate_memory_chunk(interp,
                size * sizeof (Pcc_cell));
    else
        new_array = (Pcc_cell *)Parrot_gc_allocate_fixed_size_storage(interp,
                size * sizeof (Pcc_cell));

    GETATTR_CallContext_positionals(interp, self, array);

    if (array) {
        GETATTR_CallContext_num_positionals(interp, self, num_positionals);
        memcpy(new_array, array, num_positionals * sizeof (Pcc_cell));

        if (allocated_positionals > 8)
            Parrot_gc_free_memory_chunk(interp, array);
        else
            Parrot_gc_free_fixed_size_storage(interp,
                allocated_positionals * sizeof (Pcc_cell), array);
    }

    SETATTR_CallContext_allocated_positionals(interp, self, size);
    SETATTR_CallContext_positionals(interp, self, new_array);
}

/*

=item C<static Pcc_cell* get_cell_at(PARROT_INTERP, PMC *self, INTVAL key)>

Return the cell indexed by C<key>.

=cut

*/

PARROT_CANNOT_RETURN_NULL
static Pcc_cell*
get_cell_at(PARROT_INTERP, ARGIN(PMC *self), INTVAL key)
{
    ASSERT_ARGS(get_cell_at)
    Pcc_cell *cells;
    ensure_positionals_storage(interp, self, key + 1);
    GETATTR_CallContext_positionals(interp, self, cells);
    return &cells[key];
}

/*

=item C<static INTVAL autobox_intval(PARROT_INTERP, const Pcc_cell *cell)>

Return C<cell> as an INTVAL.

=cut

*/

static INTVAL
autobox_intval(PARROT_INTERP, ARGIN(const Pcc_cell *cell))
{
    ASSERT_ARGS(autobox_intval)
    switch (CELL_TYPE_MASK(cell)) {
      case INTCELL:
        return CELL_INT(cell);
      case FLOATCELL:
        return (INTVAL)CELL_FLOAT(cell);
      case STRINGCELL:
        return CELL_STRING(cell) ? Parrot_str_to_int(interp, CELL_STRING(cell)) : 0;
      case PMCCELL:
        return VTABLE_get_integer(interp, CELL_PMC(cell));
      default:
        break;
    }

    /* exception */
    return 0;
}

/*

=item C<static FLOATVAL autobox_floatval(PARROT_INTERP, const Pcc_cell *cell)>

Return C<cell> as an FLOATVAL.

=cut

*/

static FLOATVAL
autobox_floatval(PARROT_INTERP, ARGIN(const Pcc_cell *cell))
{
    ASSERT_ARGS(autobox_floatval)
    switch (CELL_TYPE_MASK(cell)) {
      case INTCELL:
        return (FLOATVAL)CELL_INT(cell);
      case FLOATCELL:
        return CELL_FLOAT(cell);
      case STRINGCELL:
        return CELL_STRING(cell) ? Parrot_str_to_num(interp, CELL_STRING(cell)) : 0.0;
      case PMCCELL:
        return VTABLE_get_number(interp, CELL_PMC(cell));
      default:
        break;
    }

    /* exception */
    return 0.0;
}

/*

=item C<static STRING * autobox_string(PARROT_INTERP, const Pcc_cell *cell)>

Return C<cell> as an STRING.

=cut

*/

PARROT_CANNOT_RETURN_NULL
static STRING *
autobox_string(PARROT_INTERP, ARGIN(const Pcc_cell *cell))
{
    ASSERT_ARGS(autobox_string)
    switch (CELL_TYPE_MASK(cell)) {
      case INTCELL:
        return Parrot_str_from_int(interp, CELL_INT(cell));
      case FLOATCELL:
        return Parrot_str_from_num(interp, CELL_FLOAT(cell));
      case STRINGCELL:
        return CELL_STRING(cell);
      case PMCCELL:
        return VTABLE_get_string(interp, CELL_PMC(cell));
      default:
        break;
    }

    /* exception */
    return STRINGNULL;
}

/*

=item C<static PMC * autobox_pmc(PARROT_INTERP, Pcc_cell *cell, INTVAL type)>

Return C<cell> as a PMC.

=cut

*/

PARROT_CANNOT_RETURN_NULL
static PMC *
autobox_pmc(PARROT_INTERP, ARGIN(Pcc_cell *cell), INTVAL type)
{
    ASSERT_ARGS(autobox_pmc)
    PMC *result = PMCNULL;

    switch (type) {
      case INTCELL:
        result = Parrot_pmc_new(interp, HLL_TYPE(enum_class_Integer));
        VTABLE_set_integer_native(interp, result, CELL_INT(cell));
        break;
      case FLOATCELL:
        result = Parrot_pmc_new(interp, HLL_TYPE(enum_class_Float));
        VTABLE_set_number_native(interp, result, CELL_FLOAT(cell));
        break;
      case STRINGCELL:
        result = Parrot_pmc_box_string(interp, CELL_STRING(cell));
        break;
      case PMCCELL:
        result = CELL_PMC(cell);
      default:
        /* exception */
        break;
    }

    return result;
}

/*

=item C<static Hash * get_hash(PARROT_INTERP, PMC *SELF)>

Return the hash for this CallContext, creating a hash if necessary.

=cut

*/

PARROT_CANNOT_RETURN_NULL
static Hash *
get_hash(PARROT_INTERP, ARGIN(PMC *SELF))
{
    ASSERT_ARGS(get_hash)
    Hash   *hash;

    GETATTR_CallContext_hash(interp, SELF, hash);

    if (!hash) {
        hash = Parrot_hash_create(interp,
            enum_type_ptr,
            Hash_key_type_STRING);

        SETATTR_CallContext_hash(interp, SELF, hash);
    }

    return hash;
}

/*

=item C<static void mark_cell(PARROT_INTERP, Pcc_cell *c)>

Mark this cell's GCable, if needed.

=cut

*/

static void
mark_cell(PARROT_INTERP, ARGIN(Pcc_cell *c))
{
    ASSERT_ARGS(mark_cell)
    switch (CELL_TYPE_MASK(c)) {
        case STRINGCELL:
            if (CELL_STRING(c))
                Parrot_gc_mark_STRING_alive(interp, CELL_STRING(c));
            break;
        case PMCCELL:
            if (!PMC_IS_NULL(CELL_PMC(c)))
                Parrot_gc_mark_PMC_alive(interp, CELL_PMC(c));
            break;
        case INTCELL:
        case FLOATCELL:
        default:
            break;
    }

}

/*

=item C<static void mark_positionals(PARROT_INTERP, PMC *self)>

Mark this positional's GCables, if needed.

=cut

*/

static void
mark_positionals(PARROT_INTERP, ARGIN(PMC *self))
{
    ASSERT_ARGS(mark_positionals)
    INTVAL size;

    GETATTR_CallContext_num_positionals(interp, self, size);

    if (size) {
        Pcc_cell *cells;
        INTVAL i;
        GETATTR_CallContext_positionals(interp, self, cells);

        for (i = 0; i < size; ++i)
            mark_cell(interp, &cells[i]);
    }
}

/*

=item C<static void mark_hash(PARROT_INTERP, Hash *h)>

Mark this hash's GCables, if needed.

=cut

*/

/* don't look now, but here goes encapsulation.... */
static void
mark_hash(PARROT_INTERP, ARGIN(Hash *h))
{
    ASSERT_ARGS(mark_hash)
    parrot_hash_iterate(h,
        Parrot_gc_mark_STRING_alive(interp, (STRING *)_bucket->key);
        mark_cell(interp, (Pcc_cell *)_bucket->value););
}

/*

=item C<static PMC * get_named_names(PARROT_INTERP, PMC *SELF)>

Return all named arguments in a FixedStringArray.

=cut

*/

PARROT_CAN_RETURN_NULL
static PMC *
get_named_names(PARROT_INTERP, ARGIN(PMC *SELF))
{
    ASSERT_ARGS(get_named_names)
    Hash *hash;

    GETATTR_CallContext_hash(interp, SELF, hash);

    /* yes, this *looks* risky, but it's a Parrot STRING hash internally */
    if (hash && hash->entries) {
        UINTVAL j = 0;
        PMC * const result =
            Parrot_pmc_new_init_int(interp, enum_class_FixedStringArray, hash->entries);
        parrot_hash_iterate(hash,
            VTABLE_set_string_keyed_int(interp, result, j++, (STRING *)_bucket->key););
        return result;
    }

    return PMCNULL;
}

#include "parrot/packfile.h"
#include "pmc/pmc_sub.h"
#line 552 "./src/pmc/callcontext.c"
void    Parrot_CallContext_ro_class_init(PARROT_INTERP, int, int);
  PMC  *
Parrot_CallContext_clone(PARROT_INTERP, ARGMOD(PMC *_self))
{
#line 1564 "./src/pmc/callcontext.pmc"

    STRING      *short_sig;
    PMC         *type_tuple, *arg_flags, *return_flags;

    PMC * const  dest = Parrot_pmc_new(interp, _self->vtable->base_type);
    INTVAL       num;
    Pcc_cell    *our_cells, *dest_cells;
    Hash        *hash;

    GETATTR_CallContext_num_positionals(interp, _self, num);
    /* Copy positionals */
    ensure_positionals_storage(interp, dest, num);
    GETATTR_CallContext_positionals(interp, _self, our_cells);
    GETATTR_CallContext_positionals(interp, dest, dest_cells);
    memcpy(dest_cells, our_cells, num * sizeof (Pcc_cell));
    SETATTR_CallContext_num_positionals(interp, dest, num);

    GETATTR_CallContext_type_tuple(interp, _self, type_tuple);
    GETATTR_CallContext_short_sig(interp, _self, short_sig);
    GETATTR_CallContext_arg_flags(interp, _self, arg_flags);
    GETATTR_CallContext_return_flags(interp, _self, return_flags);

    GETATTR_CallContext_hash(interp, _self, hash);

    if (!PMC_IS_NULL(type_tuple))
        SETATTR_CallContext_type_tuple(interp, dest, VTABLE_clone(interp, type_tuple));

    if (short_sig)
        SETATTR_CallContext_short_sig(interp, dest, short_sig);

    if (!PMC_IS_NULL(arg_flags))
        SETATTR_CallContext_arg_flags(interp, dest, VTABLE_clone(interp, arg_flags));

    if (!PMC_IS_NULL(return_flags))
        SETATTR_CallContext_return_flags(interp, dest, VTABLE_clone(interp, return_flags));

    if (hash) {
        Hash *dest_hash = get_hash(interp, dest);
        Parrot_hash_clone(interp, hash, dest_hash);
        parrot_hash_iterate(dest_hash,
            Pcc_cell *tmp;
            CLONE_CELL(interp, (Pcc_cell *)_bucket->value, tmp);
            _bucket->value = tmp;);
    }

    return dest;
#line 604 "./src/pmc/callcontext.c"
}
  void 
Parrot_CallContext_destroy(PARROT_INTERP, ARGMOD(PMC *_self))
{
#line 721 "./src/pmc/callcontext.pmc"

    INTVAL    allocated_positionals;
    Hash     *hash;

    if (!PMC_data(_self))
        return;

    GETATTR_CallContext_hash(interp, _self, hash);
    GETATTR_CallContext_allocated_positionals(interp, _self, allocated_positionals);

    if (allocated_positionals) {
        Pcc_cell *c;

        GETATTR_CallContext_positionals(interp, _self, c);
        if (allocated_positionals > 8)
            Parrot_gc_free_memory_chunk(interp, c);
        else
            Parrot_gc_free_fixed_size_storage(interp,
                allocated_positionals * sizeof (Pcc_cell), c);
    }

    if (hash) {
        parrot_hash_iterate(hash,
            FREE_CELL(interp, (Pcc_cell *)_bucket->value););
        Parrot_hash_destroy(interp, hash);
    }

    Parrot_pcc_free_registers(interp, _self);
#line 638 "./src/pmc/callcontext.c"
}
  INTVAL 
Parrot_CallContext_elements(PARROT_INTERP, ARGMOD(PMC *_self))
{
#line 1032 "./src/pmc/callcontext.pmc"

    INTVAL num_positionals;

    if (!PMC_data(_self))
        return 0;

    GETATTR_CallContext_num_positionals(interp, _self, num_positionals);

    return num_positionals;
#line 653 "./src/pmc/callcontext.c"
}
  INTVAL 
Parrot_CallContext_exists_keyed(PARROT_INTERP, ARGMOD(PMC *_self), PMC *key)
{
#line 1520 "./src/pmc/callcontext.pmc"

    Hash *hash;
    GETATTR_CallContext_hash(interp, _self, hash);

    if (hash) {
        void * const k = Parrot_hash_key_from_pmc(interp, hash, key);
        return Parrot_hash_exists(interp, hash, k);
    }

    return 0;
#line 669 "./src/pmc/callcontext.c"
}
  INTVAL 
Parrot_CallContext_exists_keyed_int(PARROT_INTERP, ARGMOD(PMC *_self), INTVAL key)
{
#line 1544 "./src/pmc/callcontext.pmc"

    INTVAL num_positionals;

    GETATTR_CallContext_num_positionals(interp, _self, num_positionals);

    if (num_positionals)
        return key < num_positionals;

    return 0;
#line 684 "./src/pmc/callcontext.c"
}
  INTVAL 
Parrot_CallContext_exists_keyed_str(PARROT_INTERP, ARGMOD(PMC *_self), STRING *key)
{
#line 1532 "./src/pmc/callcontext.pmc"

    Hash *hash;
    GETATTR_CallContext_hash(interp, _self, hash);

    if (hash) {
        void * const k = Parrot_hash_key_from_string(interp, hash, key);
        return Parrot_hash_exists(interp, hash, k);
    }

    return 0;
#line 700 "./src/pmc/callcontext.c"
}
  PMC  *
Parrot_CallContext_get_attr_str(PARROT_INTERP, ARGMOD(PMC *_self), STRING *key)
{
#line 988 "./src/pmc/callcontext.pmc"

    PMC    *value = PMCNULL;
    INTVAL  hll;

    if (STRING_equal(interp, key, CONST_STRING(interp, "named"))) {
        value = get_named_names(interp, _self);
    }
    else if (STRING_equal(interp, key, CONST_STRING(interp, "arg_flags")))
        GETATTR_CallContext_arg_flags(interp, _self, value);
    else if (STRING_equal(interp, key, CONST_STRING(interp, "return_flags")))
        GETATTR_CallContext_return_flags(interp, _self, value);
    else if (STRING_equal(interp, key, CONST_STRING(interp, "caller_ctx")))
        GETATTR_CallContext_caller_ctx(interp, _self, value);
    else if (STRING_equal(interp, key, CONST_STRING(interp, "lex_pad")))
        GETATTR_CallContext_lex_pad(interp, _self, value);
    else if (STRING_equal(interp, key, CONST_STRING(interp, "outer_ctx")))
        GETATTR_CallContext_outer_ctx(interp, _self, value);
    else if (STRING_equal(interp, key, CONST_STRING(interp, "current_sub")))
        GETATTR_CallContext_current_sub(interp, _self, value);
    else if (STRING_equal(interp, key, CONST_STRING(interp, "current_cont")))
        GETATTR_CallContext_current_cont(interp, _self, value);
    else if (STRING_equal(interp, key, CONST_STRING(interp, "current_namespace")))
        GETATTR_CallContext_current_namespace(interp, _self, value);
    else if (STRING_equal(interp, key, CONST_STRING(interp, "handlers")))
        GETATTR_CallContext_handlers(interp, _self, value);
    else if (STRING_equal(interp, key, CONST_STRING(interp, "current_HLL"))) {
        GETATTR_CallContext_current_HLL(interp, _self, hll);
        value = Parrot_pmc_new(interp, Parrot_hll_get_ctx_HLL_type(interp, enum_class_Integer));
        VTABLE_set_integer_native(interp, value, hll);
    }
    else if (STRING_equal(interp, key, CONST_STRING(interp, "current_hll"))) {
        GETATTR_CallContext_current_HLL(interp, _self, hll);
        value = Parrot_pmc_new(interp, Parrot_hll_get_ctx_HLL_type(interp, enum_class_String));
        VTABLE_set_string_native(interp, value, Parrot_hll_get_HLL_name(interp, hll));
    }
    else
        Parrot_ex_throw_from_c_args(interp, NULL,
            EXCEPTION_ATTRIB_NOT_FOUND, "No such attribute '%S'", key);

    if (value)
        return value;
    return PMCNULL;
#line 748 "./src/pmc/callcontext.c"
}
  INTVAL 
Parrot_CallContext_get_integer_keyed(PARROT_INTERP, ARGMOD(PMC *_self), PMC *key)
{
#line 1453 "./src/pmc/callcontext.pmc"

    Hash *hash;
    GETATTR_CallContext_hash(interp, _self, hash);

    if (hash) {
        void     * const k    = Parrot_hash_key_from_pmc(interp, hash, key);
        Pcc_cell * const cell = (Pcc_cell *)Parrot_hash_get(interp, hash, k);

        if (cell) {
            if (CELL_TYPE_MASK(cell) == INTCELL)
                return CELL_INT(cell);
            return autobox_intval(interp, cell);
        }
    }

    return 0;
#line 770 "./src/pmc/callcontext.c"
}
  INTVAL 
Parrot_CallContext_get_integer_keyed_int(PARROT_INTERP, ARGMOD(PMC *_self), INTVAL key)
{
#line 1170 "./src/pmc/callcontext.pmc"

    Pcc_cell *cells;
    INTVAL    num_pos;

    GETATTR_CallContext_num_positionals(interp, _self, num_pos);
    if (key >= num_pos || key < 0)
        return 0;

    GETATTR_CallContext_positionals(interp, _self, cells);
    {
        const Pcc_cell *cell = &cells[key];
        if (CELL_TYPE_MASK(cell) == INTCELL)
            return CELL_INT(cell);

        return autobox_intval(interp, cell);
    }
#line 792 "./src/pmc/callcontext.c"
}
  INTVAL 
Parrot_CallContext_get_integer_keyed_str(PARROT_INTERP, ARGMOD(PMC *_self), STRING *key)
{
#line 1383 "./src/pmc/callcontext.pmc"

    Hash *hash;
    GETATTR_CallContext_hash(interp, _self, hash);

    if (hash) {
        void     * const k    = Parrot_hash_key_from_string(interp, hash, key);
        Pcc_cell * const cell = (Pcc_cell *)Parrot_hash_get(interp, hash, k);

        if (cell) {
            if (CELL_TYPE_MASK(cell) == INTCELL)
                return CELL_INT(cell);

            return autobox_intval(interp, cell);
        }
    }

    return 0;
#line 815 "./src/pmc/callcontext.c"
}
  FLOATVAL 
Parrot_CallContext_get_number_keyed(PARROT_INTERP, ARGMOD(PMC *_self), PMC *key)
{
#line 1471 "./src/pmc/callcontext.pmc"

    Hash *hash;
    GETATTR_CallContext_hash(interp, _self, hash);

    if (hash) {
        void     * const k    = Parrot_hash_key_from_pmc(interp, hash, key);
        Pcc_cell * const cell = (Pcc_cell *)Parrot_hash_get(interp, hash, k);

        if (cell)
            return autobox_floatval(interp, cell);
    }

    return 0.0;
#line 834 "./src/pmc/callcontext.c"
}
  FLOATVAL 
Parrot_CallContext_get_number_keyed_int(PARROT_INTERP, ARGMOD(PMC *_self), INTVAL key)
{
#line 1188 "./src/pmc/callcontext.pmc"

    Pcc_cell *cells;
    INTVAL    num_pos;

    GETATTR_CallContext_num_positionals(interp, _self, num_pos);
    if (key >= num_pos || key < 0)
        return 0.0;

    GETATTR_CallContext_positionals(interp, _self, cells);
    return autobox_floatval(interp, &cells[key]);
#line 850 "./src/pmc/callcontext.c"
}
  FLOATVAL 
Parrot_CallContext_get_number_keyed_str(PARROT_INTERP, ARGMOD(PMC *_self), STRING *key)
{
#line 1402 "./src/pmc/callcontext.pmc"

    Hash *hash;
    GETATTR_CallContext_hash(interp, _self, hash);

    if (hash) {
        void     * const k    = Parrot_hash_key_from_string(interp, hash, key);
        Pcc_cell * const cell = (Pcc_cell *)Parrot_hash_get(interp, hash, k);

        if (cell)
            return autobox_floatval(interp, cell);
    }

    return 0.0;
#line 869 "./src/pmc/callcontext.c"
}
  PMC  *
Parrot_CallContext_get_pmc(PARROT_INTERP, ARGMOD(PMC *_self))
{
#line 843 "./src/pmc/callcontext.pmc"

    PMC *type_tuple;

    GETATTR_CallContext_type_tuple(interp, _self, type_tuple);

    if (PMC_IS_NULL(type_tuple)) {
        Pcc_cell *c;
        INTVAL    num_positionals;
        INTVAL    i = 0;

        GETATTR_CallContext_positionals(interp, _self, c);
        GETATTR_CallContext_num_positionals(interp, _self, num_positionals);

        type_tuple = Parrot_pmc_new_init_int(interp,
            enum_class_FixedIntegerArray, num_positionals);

        for (i = 0; i < num_positionals; ++i) {
            INTVAL type;

            switch (c[i].type) {
                case INTCELL:    type = -enum_type_INTVAL;   break;
                case FLOATCELL:  type = -enum_type_FLOATVAL; break;
                case STRINGCELL: type = -enum_type_STRING;   break;
                case PMCCELL:
                    type = PMC_IS_NULL(c[i].u.p)
                         ? (INTVAL)-enum_type_PMC
                         : VTABLE_type(interp, c[i].u.p);
                    break;
                default:
                    Parrot_ex_throw_from_c_args(interp, NULL,
                        EXCEPTION_INVALID_OPERATION,
                        "Multiple Dispatch: invalid argument type!");
            }

            VTABLE_set_integer_keyed_int(interp, type_tuple, i, type);
        }

        SETATTR_CallContext_type_tuple(interp, _self, type_tuple);
    }

    return type_tuple;
#line 916 "./src/pmc/callcontext.c"
}
  PMC * 
Parrot_CallContext_get_pmc_keyed(PARROT_INTERP, ARGMOD(PMC *_self), PMC *key)
{
#line 1501 "./src/pmc/callcontext.pmc"

    Hash *hash;
    GETATTR_CallContext_hash(interp, _self, hash);

    if (hash) {
        void     * const k    = Parrot_hash_key_from_pmc(interp, hash, key);
        Pcc_cell * const cell = (Pcc_cell *)Parrot_hash_get(interp, hash, k);

        if (cell) {
            const INTVAL type = CELL_TYPE_MASK(cell);
            if (type == PMCCELL)
                return CELL_PMC(cell);
            return autobox_pmc(interp, cell, type);
        }
    }

    return PMCNULL;
#line 939 "./src/pmc/callcontext.c"
}
  PMC * 
Parrot_CallContext_get_pmc_keyed_int(PARROT_INTERP, ARGMOD(PMC *_self), INTVAL key)
{
#line 1212 "./src/pmc/callcontext.pmc"

    Pcc_cell *cells;
    INTVAL    num_pos, type;

    GETATTR_CallContext_num_positionals(interp, _self, num_pos);
    if (key >= num_pos || key < 0)
        return PMCNULL;

    GETATTR_CallContext_positionals(interp, _self, cells);
    type = CELL_TYPE_MASK(&cells[key]);
    if (type == PMCCELL)
        return CELL_PMC(&cells[key]);
    return autobox_pmc(interp, &cells[key], type);
#line 958 "./src/pmc/callcontext.c"
}
  PMC * 
Parrot_CallContext_get_pmc_keyed_str(PARROT_INTERP, ARGMOD(PMC *_self), STRING *key)
{
#line 1433 "./src/pmc/callcontext.pmc"

    Hash *hash;
    GETATTR_CallContext_hash(interp, _self, hash);

    if (hash) {
        void     * const k    = Parrot_hash_key_from_string(interp, hash, key);
        Pcc_cell * const cell = (Pcc_cell *)Parrot_hash_get(interp, hash, k);

        if (cell) {
            const INTVAL type = CELL_TYPE_MASK(cell);
            if (type == PMCCELL) {
                return CELL_PMC(cell);
            }
            return autobox_pmc(interp, cell, type);
        }
    }

    return PMCNULL;
#line 982 "./src/pmc/callcontext.c"
}
  STRING  *
Parrot_CallContext_get_string(PARROT_INTERP, ARGMOD(PMC *_self))
{
#line 775 "./src/pmc/callcontext.pmc"

    STRING   *res;
    Pcc_cell *c;
    INTVAL    num_positionals, i;

    GETATTR_CallContext_short_sig(interp, _self, res);

    if (res) {
        #line 996 "./src/pmc/callcontext.c"
    return (STRING*)res;
#line 783 "./src/pmc/callcontext.pmc"

    }

    GETATTR_CallContext_positionals(interp, _self, c);
    GETATTR_CallContext_num_positionals(interp, _self, num_positionals);

    res = Parrot_str_new(interp, NULL, num_positionals);

    for (i = 0; i < num_positionals; ++i) {
        switch (c[i].type) {
          case INTCELL:
            res = Parrot_str_concat(interp, res, CONST_STRING(interp, "I"));
            break;
          case FLOATCELL:
            res = Parrot_str_concat(interp, res, CONST_STRING(interp, "N"));
            break;
          case STRINGCELL:
            res = Parrot_str_concat(interp, res, CONST_STRING(interp, "S"));
            break;
          case PMCCELL:
            res = Parrot_str_concat(interp, res, CONST_STRING(interp, "P"));
            break;
          default:
            PARROT_FAILURE("Impossible flag");
            break;
        }
    }
    /* TODO Add named args to signature */
    /* After fixind build_MMD_type_tuple to use raw arguments instead of signature */

    SETATTR_CallContext_short_sig(interp, _self, res);

    #line 1031 "./src/pmc/callcontext.c"
    return (STRING*)res;
#line 815 "./src/pmc/callcontext.pmc"

#line 1035 "./src/pmc/callcontext.c"
}
  STRING * 
Parrot_CallContext_get_string_keyed(PARROT_INTERP, ARGMOD(PMC *_self), PMC *key)
{
#line 1486 "./src/pmc/callcontext.pmc"

    Hash *hash;
    GETATTR_CallContext_hash(interp, _self, hash);

    if (hash) {
        void     * const k    = Parrot_hash_key_from_pmc(interp, hash, key);
        Pcc_cell * const cell = (Pcc_cell *)Parrot_hash_get(interp, hash, k);

        if (cell)
            return autobox_string(interp, cell);
    }

    return STRINGNULL;
#line 1054 "./src/pmc/callcontext.c"
}
  STRING * 
Parrot_CallContext_get_string_keyed_int(PARROT_INTERP, ARGMOD(PMC *_self), INTVAL key)
{
#line 1200 "./src/pmc/callcontext.pmc"

    Pcc_cell *cells;
    INTVAL    num_pos;

    GETATTR_CallContext_num_positionals(interp, _self, num_pos);
    if (key >= num_pos || key < 0)
        return STRINGNULL;

    GETATTR_CallContext_positionals(interp, _self, cells);
    return autobox_string(interp, &cells[key]);
#line 1070 "./src/pmc/callcontext.c"
}
  STRING * 
Parrot_CallContext_get_string_keyed_str(PARROT_INTERP, ARGMOD(PMC *_self), STRING *key)
{
#line 1418 "./src/pmc/callcontext.pmc"

    Hash *hash;
    GETATTR_CallContext_hash(interp, _self, hash);

    if (hash) {
        void     * const k    = Parrot_hash_key_from_string(interp, hash, key);
        Pcc_cell * const cell = (Pcc_cell *)Parrot_hash_get(interp, hash, k);

        if (cell)
            return autobox_string(interp, cell);
    }

    return STRINGNULL;
#line 1089 "./src/pmc/callcontext.c"
}
  void 
Parrot_CallContext_init(PARROT_INTERP, ARGMOD(PMC *_self))
{
#line 587 "./src/pmc/callcontext.pmc"

    SETATTR_CallContext_type_tuple(interp, _self, PMCNULL);

    SETATTR_CallContext_positionals(interp, _self, NULL);
    SETATTR_CallContext_num_positionals(interp, _self, 0);

    PObj_custom_mark_destroy_SETALL(_self);
    PARROT_GC_WRITE_BARRIER(interp, _self);
#line 1103 "./src/pmc/callcontext.c"
}
  void 
Parrot_CallContext_mark(PARROT_INTERP, ARGMOD(PMC *_self))
{
#line 605 "./src/pmc/callcontext.pmc"

    Hash     *hash;
    PMC      *tmp;
    STRING   *short_sig;
    UINTVAL  *n_regs_used;

    if (!PMC_data(_self))
        return;

    GETATTR_CallContext_short_sig(interp, _self, short_sig);
    Parrot_gc_mark_STRING_alive(interp, short_sig);

    mark_positionals(interp, _self);

    GETATTR_CallContext_hash(interp, _self, hash);
    if (hash)
        mark_hash(interp, hash);

    GETATTR_CallContext_arg_flags(interp, _self, tmp);
    Parrot_gc_mark_PMC_alive(interp, tmp);

    GETATTR_CallContext_return_flags(interp, _self, tmp);
    Parrot_gc_mark_PMC_alive(interp, tmp);

    GETATTR_CallContext_type_tuple(interp, _self, tmp);
    Parrot_gc_mark_PMC_alive(interp, tmp);

    GETATTR_CallContext_caller_ctx(interp, _self, tmp);
    Parrot_gc_mark_PMC_alive(interp, tmp);

    GETATTR_CallContext_lex_pad(interp, _self, tmp);
    Parrot_gc_mark_PMC_alive(interp, tmp);

    GETATTR_CallContext_outer_ctx(interp, _self, tmp);
    Parrot_gc_mark_PMC_alive(interp, tmp);

    GETATTR_CallContext_current_sub(interp, _self, tmp);
    Parrot_gc_mark_PMC_alive(interp, tmp);

    GETATTR_CallContext_handlers(interp, _self, tmp);
    Parrot_gc_mark_PMC_alive(interp, tmp);

    GETATTR_CallContext_current_cont(interp, _self, tmp);
    Parrot_gc_mark_PMC_alive(interp, tmp);

    GETATTR_CallContext_current_namespace(interp, _self, tmp);
    Parrot_gc_mark_PMC_alive(interp, tmp);

    GETATTR_CallContext_current_sig(interp, _self, tmp);
    Parrot_gc_mark_PMC_alive(interp, tmp);

    /* We don't keep reusable continuation alive. It will keep too many
       other things alive as well. Just NULL it */
    SETATTR_CallContext_continuation(interp, _self, PMCNULL);

    GETATTR_CallContext_n_regs_used(interp, _self, n_regs_used);

    if (n_regs_used) {
        Regs_ps         bp_ps;
        const UINTVAL   regs_p = n_regs_used[REGNO_PMC];
        const UINTVAL   regs_s = n_regs_used[REGNO_STR];
        UINTVAL         i;

        GETATTR_CallContext_bp_ps(interp, _self, bp_ps);

        for (i = 0; i < regs_p; ++i) {
            PMC * const p = bp_ps.regs_p[-1L-(i)];
            /* Original code from CTX_REG_PMC */
            if (p)
                Parrot_gc_mark_PMC_alive(interp, p);
        }

        for (i = 0; i < regs_s; ++i) {
            STRING * const s = bp_ps.regs_s[i];
            if (s)
                Parrot_gc_mark_STRING_alive(interp, s);
        }
    }
#line 1187 "./src/pmc/callcontext.c"
}
  void 
Parrot_CallContext_morph(PARROT_INTERP, ARGMOD(PMC *_self), SHIM(PMC *type))
{
#line 696 "./src/pmc/callcontext.pmc"
    Hash     *hash;

    if (!PMC_data(_self))
        return;

    SETATTR_CallContext_short_sig(interp, _self, NULL);
    SETATTR_CallContext_arg_flags(interp, _self, PMCNULL);
    SETATTR_CallContext_return_flags(interp, _self, PMCNULL);
    SETATTR_CallContext_type_tuple(interp, _self, PMCNULL);

    /* Don't free positionals. Just reuse them */
    SETATTR_CallContext_num_positionals(interp, _self, 0);

    GETATTR_CallContext_hash(interp, _self, hash);

    if (hash) {
        parrot_hash_iterate(hash,
           FREE_CELL(interp, (Pcc_cell *)_bucket->value););
        Parrot_hash_destroy(interp, hash);
        SETATTR_CallContext_hash(interp, _self, NULL);
    }
    PARROT_GC_WRITE_BARRIER(interp, _self);
#line 1215 "./src/pmc/callcontext.c"
}
  void 
Parrot_CallContext_push_float(PARROT_INTERP, ARGMOD(PMC *_self), FLOATVAL value)
{
#line 1059 "./src/pmc/callcontext.pmc"

    Pcc_cell *cells;
    INTVAL    num_pos;

    GETATTR_CallContext_num_positionals(interp, _self, num_pos);
    ensure_positionals_storage(interp, _self, num_pos + 1);

    GETATTR_CallContext_positionals(interp, _self, cells);
    cells[num_pos].u.n      = value;
    cells[num_pos].type     = FLOATCELL;
    SETATTR_CallContext_num_positionals(interp, _self, num_pos + 1);
    PARROT_GC_WRITE_BARRIER(interp, _self);
#line 1233 "./src/pmc/callcontext.c"
}
  void 
Parrot_CallContext_push_integer(PARROT_INTERP, ARGMOD(PMC *_self), INTVAL value)
{
#line 1043 "./src/pmc/callcontext.pmc"

    Pcc_cell *cells;
    INTVAL    num_pos, allocated_positionals;

    GETATTR_CallContext_num_positionals(interp, _self, num_pos);
    GETATTR_CallContext_allocated_positionals(interp, _self, allocated_positionals);

    if (num_pos + 1 > allocated_positionals)
        ensure_positionals_storage_ap(interp, _self, num_pos + 1, allocated_positionals);

    GETATTR_CallContext_positionals(interp, _self, cells);
    cells[num_pos].u.i      = value;
    cells[num_pos].type     = INTCELL;
    SETATTR_CallContext_num_positionals(interp, _self, num_pos + 1);
    PARROT_GC_WRITE_BARRIER(interp, _self);
#line 1254 "./src/pmc/callcontext.c"
}
  void 
Parrot_CallContext_push_pmc(PARROT_INTERP, ARGMOD(PMC *_self), PMC *value)
{
#line 1085 "./src/pmc/callcontext.pmc"

    Pcc_cell *cells;
    INTVAL    num_pos, allocated_positionals;

    PARROT_ASSERT(!PObj_on_free_list_TEST(value)
            || !"Push dead object into CallContext!");

    GETATTR_CallContext_num_positionals(interp, _self, num_pos);
    GETATTR_CallContext_allocated_positionals(interp, _self, allocated_positionals);

    if (num_pos + 1 > allocated_positionals)
        ensure_positionals_storage_ap(interp, _self, num_pos + 1, allocated_positionals);

    GETATTR_CallContext_positionals(interp, _self, cells);
    cells[num_pos].u.p      = value;
    cells[num_pos].type     = PMCCELL;
    SETATTR_CallContext_num_positionals(interp, _self, num_pos + 1);
    PARROT_GC_WRITE_BARRIER(interp, _self);
#line 1278 "./src/pmc/callcontext.c"
}
  void 
Parrot_CallContext_push_string(PARROT_INTERP, ARGMOD(PMC *_self), STRING *value)
{
#line 1072 "./src/pmc/callcontext.pmc"

    Pcc_cell *cells;
    INTVAL    num_pos;

    GETATTR_CallContext_num_positionals(interp, _self, num_pos);
    ensure_positionals_storage(interp, _self, num_pos + 1);

    GETATTR_CallContext_positionals(interp, _self, cells);
    cells[num_pos].u.s      = value;
    cells[num_pos].type     = STRINGCELL;
    SETATTR_CallContext_num_positionals(interp, _self, num_pos + 1);
    PARROT_GC_WRITE_BARRIER(interp, _self);
#line 1296 "./src/pmc/callcontext.c"
}
  void 
Parrot_CallContext_set_attr_str(PARROT_INTERP, ARGMOD(PMC *_self), STRING *key, PMC *value)
{
#line 915 "./src/pmc/callcontext.pmc"


    if (STRING_equal(interp, key, CONST_STRING(interp, "arg_flags"))) {
        SETATTR_CallContext_arg_flags(interp, _self, value);
    }
    else if (STRING_equal(interp, key, CONST_STRING(interp, "return_flags"))) {
        SETATTR_CallContext_return_flags(interp, _self, value);
    }
    else
        Parrot_ex_throw_from_c_args(interp, NULL,
            EXCEPTION_ATTRIB_NOT_FOUND, "No such attribute '%S'", key);
    PARROT_GC_WRITE_BARRIER(interp, _self);
#line 1314 "./src/pmc/callcontext.c"
}
  void 
Parrot_CallContext_set_integer_keyed(PARROT_INTERP, ARGMOD(PMC *_self), PMC *key, INTVAL value)
{
#line 1327 "./src/pmc/callcontext.pmc"

    Hash     * const hash = get_hash(interp, _self);
    void     * const k    = Parrot_hash_key_from_pmc(interp, hash, key);
    Pcc_cell *cell = (Pcc_cell *)Parrot_hash_get(interp, hash, k);

    if (!cell) {
        cell = ALLOC_CELL(interp);
        Parrot_hash_put(interp, hash, k, (void *)cell);
    }

    cell->u.i       = value;
    cell->type      = INTCELL;
    PARROT_GC_WRITE_BARRIER(interp, _self);
#line 1333 "./src/pmc/callcontext.c"
}
  void 
Parrot_CallContext_set_integer_keyed_int(PARROT_INTERP, ARGMOD(PMC *_self), INTVAL key, INTVAL value)
{
#line 1227 "./src/pmc/callcontext.pmc"

    Pcc_cell * const cell = get_cell_at(interp, _self, key);
    INTVAL    pos;

    cell->u.i   = value;
    cell->type  = INTCELL;

    GETATTR_CallContext_num_positionals(interp, _self, pos);
    if (pos <= key)
        SETATTR_CallContext_num_positionals(interp, _self, key + 1);
    PARROT_GC_WRITE_BARRIER(interp, _self);
#line 1350 "./src/pmc/callcontext.c"
}
  void 
Parrot_CallContext_set_integer_keyed_str(PARROT_INTERP, ARGMOD(PMC *_self), STRING *key, INTVAL value)
{
#line 1275 "./src/pmc/callcontext.pmc"

    Hash     * const hash = get_hash(interp, _self);
    Pcc_cell *cell = (Pcc_cell *)Parrot_hash_get(interp, hash, (void *)key);

    if (!cell) {
        cell = ALLOC_CELL(interp);
        Parrot_hash_put(interp, hash, (void *)key, (void *)cell);
    }

    cell->u.i       = value;
    cell->type      = INTCELL;
    PARROT_GC_WRITE_BARRIER(interp, _self);
#line 1368 "./src/pmc/callcontext.c"
}
  void 
Parrot_CallContext_set_number_keyed(PARROT_INTERP, ARGMOD(PMC *_self), PMC *key, FLOATVAL value)
{
#line 1341 "./src/pmc/callcontext.pmc"

    Hash     * const hash = get_hash(interp, _self);
    void     * const k    = Parrot_hash_key_from_pmc(interp, hash, key);
    Pcc_cell *cell = (Pcc_cell *)Parrot_hash_get(interp, hash, k);

    if (!cell) {
        cell = ALLOC_CELL(interp);
        Parrot_hash_put(interp, hash, k, (void *)cell);
    }

    cell->u.n       = value;
    cell->type      = FLOATCELL;
    PARROT_GC_WRITE_BARRIER(interp, _self);
#line 1387 "./src/pmc/callcontext.c"
}
  void 
Parrot_CallContext_set_number_keyed_int(PARROT_INTERP, ARGMOD(PMC *_self), INTVAL key, FLOATVAL value)
{
#line 1239 "./src/pmc/callcontext.pmc"

    Pcc_cell * const cell = get_cell_at(interp, _self, key);
    INTVAL    pos;

    cell->u.n   = value;
    cell->type  = FLOATCELL;

    GETATTR_CallContext_num_positionals(interp, _self, pos);
    if (pos <= key)
        SETATTR_CallContext_num_positionals(interp, _self, key + 1);
    PARROT_GC_WRITE_BARRIER(interp, _self);
#line 1404 "./src/pmc/callcontext.c"
}
  void 
Parrot_CallContext_set_number_keyed_str(PARROT_INTERP, ARGMOD(PMC *_self), STRING *key, FLOATVAL value)
{
#line 1288 "./src/pmc/callcontext.pmc"

    Hash     * const hash = get_hash(interp, _self);
    Pcc_cell *cell = (Pcc_cell *)Parrot_hash_get(interp, hash, (void *)key);

    if (!cell) {
        cell = ALLOC_CELL(interp);
        Parrot_hash_put(interp, hash, (void *)key, (void *)cell);
    }

    cell->u.n       = value;
    cell->type      = FLOATCELL;
    PARROT_GC_WRITE_BARRIER(interp, _self);
#line 1422 "./src/pmc/callcontext.c"
}
  void 
Parrot_CallContext_set_pmc(PARROT_INTERP, ARGMOD(PMC *_self), PMC *value)
{
#line 828 "./src/pmc/callcontext.pmc"

    SETATTR_CallContext_type_tuple(interp, _self, value);
    PARROT_GC_WRITE_BARRIER(interp, _self);
#line 1431 "./src/pmc/callcontext.c"
}
  void 
Parrot_CallContext_set_pmc_keyed(PARROT_INTERP, ARGMOD(PMC *_self), PMC *key, PMC *value)
{
#line 1369 "./src/pmc/callcontext.pmc"

    Hash     * const hash = get_hash(interp, _self);
    void     * const k    = Parrot_hash_key_from_pmc(interp, hash, key);
    Pcc_cell *cell = (Pcc_cell *)Parrot_hash_get(interp, hash, k);

    if (!cell) {
        cell = ALLOC_CELL(interp);
        Parrot_hash_put(interp, hash, k, (void *)cell);
    }

    cell->u.p       = value;
    cell->type      = PMCCELL;
    PARROT_GC_WRITE_BARRIER(interp, _self);
#line 1450 "./src/pmc/callcontext.c"
}
  void 
Parrot_CallContext_set_pmc_keyed_int(PARROT_INTERP, ARGMOD(PMC *_self), INTVAL key, PMC *value)
{
#line 1263 "./src/pmc/callcontext.pmc"

    INTVAL    pos;
    Pcc_cell * const cell = get_cell_at(interp, _self, key);

    cell->u.p   = value;
    cell->type  = PMCCELL;

    GETATTR_CallContext_num_positionals(interp, _self, pos);
    if (pos <= key)
        SETATTR_CallContext_num_positionals(interp, _self, key + 1);
    PARROT_GC_WRITE_BARRIER(interp, _self);
#line 1467 "./src/pmc/callcontext.c"
}
  void 
Parrot_CallContext_set_pmc_keyed_str(PARROT_INTERP, ARGMOD(PMC *_self), STRING *key, PMC *value)
{
#line 1314 "./src/pmc/callcontext.pmc"

    Hash     * const hash = get_hash(interp, _self);
    Pcc_cell *cell = (Pcc_cell *)Parrot_hash_get(interp, hash, (void *)key);

    if (!cell) {
        cell = ALLOC_CELL(interp);
        Parrot_hash_put(interp, hash, (void *)key, (void *)cell);
    }

    cell->u.p       = value;
    cell->type      = PMCCELL;
    PARROT_GC_WRITE_BARRIER(interp, _self);
#line 1485 "./src/pmc/callcontext.c"
}
  void 
Parrot_CallContext_set_string_keyed(PARROT_INTERP, ARGMOD(PMC *_self), PMC *key, STRING *value)
{
#line 1355 "./src/pmc/callcontext.pmc"

    Hash     * const hash = get_hash(interp, _self);
    void     * const k    = Parrot_hash_key_from_pmc(interp, hash, key);
    Pcc_cell *cell = (Pcc_cell *)Parrot_hash_get(interp, hash, k);

    if (!cell) {
        cell = ALLOC_CELL(interp);
        Parrot_hash_put(interp, hash, k, (void *)cell);
    }

    cell->u.s       = value;
    cell->type      = STRINGCELL;
    PARROT_GC_WRITE_BARRIER(interp, _self);
#line 1504 "./src/pmc/callcontext.c"
}
  void 
Parrot_CallContext_set_string_keyed_int(PARROT_INTERP, ARGMOD(PMC *_self), INTVAL key, STRING *value)
{
#line 1251 "./src/pmc/callcontext.pmc"

    Pcc_cell * const cell = get_cell_at(interp, _self, key);
    INTVAL    pos;

    cell->u.s   = value;
    cell->type  = STRINGCELL;

    GETATTR_CallContext_num_positionals(interp, _self, pos);
    if (pos <= key)
        SETATTR_CallContext_num_positionals(interp, _self, key + 1);
    PARROT_GC_WRITE_BARRIER(interp, _self);
#line 1521 "./src/pmc/callcontext.c"
}
  void 
Parrot_CallContext_set_string_keyed_str(PARROT_INTERP, ARGMOD(PMC *_self), STRING *key, STRING *value)
{
#line 1301 "./src/pmc/callcontext.pmc"

    Hash     * const hash = get_hash(interp, _self);
    Pcc_cell *cell = (Pcc_cell *)Parrot_hash_get(interp, hash, (void *)key);

    if (!cell) {
        cell = ALLOC_CELL(interp);
        Parrot_hash_put(interp, hash, (void *)key, (void *)cell);
    }

    cell->u.s       = value;
    cell->type      = STRINGCELL;
    PARROT_GC_WRITE_BARRIER(interp, _self);
#line 1539 "./src/pmc/callcontext.c"
}
  void 
Parrot_CallContext_set_string_native(PARROT_INTERP, ARGMOD(PMC *_self), STRING *value)
{
#line 761 "./src/pmc/callcontext.pmc"

    SETATTR_CallContext_short_sig(interp, _self, value);
    PARROT_GC_WRITE_BARRIER(interp, _self);
#line 1548 "./src/pmc/callcontext.c"
}
  PMC * 
Parrot_CallContext_shift_pmc(PARROT_INTERP, ARGMOD(PMC *_self))
{
#line 1125 "./src/pmc/callcontext.pmc"

    Pcc_cell *cells;
    PMC      *retval;
    const INTVAL size = Parrot_CallContext_elements(interp, _self);
    INTVAL    i, type;

    if (size < 1)
        Parrot_ex_throw_from_c_args(interp, NULL,
            EXCEPTION_INVALID_OPERATION,
            "Cannot shift PMC from empty CallContext");

    GETATTR_CallContext_positionals(interp, _self, cells);
    type   = CELL_TYPE_MASK(&cells[0]);

    retval = autobox_pmc(interp, &cells[0], type);

    for (i = 1; i < size; ++i)
        cells[i - 1] = cells[i];

    SETATTR_CallContext_num_positionals(interp, _self, size - 1);
    PARROT_GC_WRITE_BARRIER(interp, _self);
    return retval;
#line 1576 "./src/pmc/callcontext.c"
}
  STRING * 
Parrot_CallContext_shift_string(PARROT_INTERP, ARGMOD(PMC *_self))
{
#line 1148 "./src/pmc/callcontext.pmc"

    Pcc_cell *cells;
    STRING   *retval;
    const INTVAL size = Parrot_CallContext_elements(interp, _self);
    INTVAL    i;

    if (size < 1)
        Parrot_ex_throw_from_c_args(interp, NULL,
            EXCEPTION_INVALID_OPERATION,
            "Cannot shift PMC from empty CallContext");

    GETATTR_CallContext_positionals(interp, _self, cells);

    retval = autobox_string(interp, &cells[0]);

    for (i = 1; i < size; ++i)
        cells[i - 1] = cells[i];

    SETATTR_CallContext_num_positionals(interp, _self, size - 1);
    PARROT_GC_WRITE_BARRIER(interp, _self);
    return retval;
#line 1603 "./src/pmc/callcontext.c"
}
  void 
Parrot_CallContext_unshift_pmc(PARROT_INTERP, ARGMOD(PMC *_self), PMC *value)
{
#line 1109 "./src/pmc/callcontext.pmc"

    Pcc_cell *cells;
    const INTVAL size = Parrot_CallContext_elements(interp, _self);
    INTVAL    i;

    ensure_positionals_storage(interp, _self, size + 1);
    GETATTR_CallContext_positionals(interp, _self, cells);

    for (i = size; i; --i)
        cells[i] = cells[i - 1];

    cells[0].u.p    = value;
    cells[0].type   = PMCCELL;
    SETATTR_CallContext_num_positionals(interp, _self, size + 1);
    PARROT_GC_WRITE_BARRIER(interp, _self);
#line 1624 "./src/pmc/callcontext.c"
}
  void
Parrot_CallContext_nci_backtrace(PARROT_INTERP, ARGMOD(PMC *_self))
{
    PMC * const _ctx         = CURRENT_CONTEXT(interp);
    PMC * const _call_object = Parrot_pcc_get_signature(interp, _ctx);

    /* BEGIN PARAMS SCOPE */
    PMC* resume;
    INTVAL has_resume;
    
    const INTVAL arity = 1; /* "PiPoIp" */
    const INTVAL arity_opt  = 1;
    INTVAL param_count = VTABLE_elements(interp, _call_object);
    if (param_count < arity)
        Parrot_ex_throw_from_c_args(interp, NULL,
                                    EXCEPTION_INVALID_OPERATION,
                                    "too few arguments: %d passed, %d expected",
                                    param_count, arity);
    if (param_count > arity + arity_opt)
        Parrot_ex_throw_from_c_args(interp, NULL,
                                    EXCEPTION_INVALID_OPERATION,
                                    "too many arguments: %d passed, %d expected",
                                    param_count, arity + arity_opt);
    _self = VTABLE_get_pmc_keyed_int(interp, _call_object, 0);
    if (param_count > 1) {
        resume = VTABLE_get_pmc_keyed_int(interp, _call_object, 1);
        has_resume = 1;
    }
    else {
        resume = PMCNULL;
        has_resume = 0;
    }

    { /* BEGIN PMETHOD BODY */
#line 1627 "./src/pmc/callcontext.pmc"

    PMC *result  = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC *cur_ctx = _self;
    Parrot_Continuation_attributes * const cont = has_resume ? PMC_cont(resume) : NULL;

    /* Get starting context, then loop over them. */
    while (cur_ctx) {
        PMC        * const frame       = Parrot_pmc_new(interp, enum_class_Hash);
        PMC        *annotations = NULL;
        Parrot_Sub_attributes *sub;

        /* Get sub and put it in the hash. */
        PMC *sub_pmc = Parrot_pcc_get_sub(interp, cur_ctx);

        if (!sub_pmc)
            sub_pmc = PMCNULL;

        VTABLE_set_pmc_keyed_str(interp, frame, CONST_STRING(interp, "sub"), sub_pmc);

        /* Look up any annotations and put them in the hash. */
        if (!PMC_IS_NULL(sub_pmc)) {
            PMC_get_sub(interp, sub_pmc, sub);

            if (sub->seg->annotations) {
                PackFile_ByteCode * const seg = sub->seg;
                opcode_t          * const pc  = cont && cur_ctx == cont->to_ctx
                                         ? cont->address
                                         : Parrot_pcc_get_pc(interp, cur_ctx);

                annotations = PackFile_Annotations_lookup(interp,
                    seg->annotations, pc - seg->base.data,
                    NULL);
            }
        }

        if (!annotations)
            annotations = Parrot_pmc_new(interp, enum_class_Hash);

        VTABLE_set_pmc_keyed_str(interp, frame, CONST_STRING(interp, "annotations"), annotations);

        /* Push frame and go to next caller. */
        VTABLE_push_pmc(interp, result, frame);
        cur_ctx = Parrot_pcc_get_caller_ctx(interp, cur_ctx);
    }

    #line 1706 "./src/pmc/callcontext.c"
     {
        VTABLE_set_pmc_keyed_int(interp, _call_object, 0, (PMC*)result);
        
        return;
     }
#line 1672 "./src/pmc/callcontext.pmc"

#line 1714 "./src/pmc/callcontext.c"

    } /* END PMETHOD BODY */

    

    /* END PARAMS SCOPE */
    return;
}
#include "pmc_default.h"

PARROT_EXPORT
VTABLE *Parrot_CallContext_update_vtable(VTABLE *vt) {
    vt->clone = Parrot_CallContext_clone;
    vt->destroy = Parrot_CallContext_destroy;
    vt->elements = Parrot_CallContext_elements;
    vt->exists_keyed = Parrot_CallContext_exists_keyed;
    vt->exists_keyed_int = Parrot_CallContext_exists_keyed_int;
    vt->exists_keyed_str = Parrot_CallContext_exists_keyed_str;
    vt->get_attr_str = Parrot_CallContext_get_attr_str;
    vt->get_integer_keyed = Parrot_CallContext_get_integer_keyed;
    vt->get_integer_keyed_int = Parrot_CallContext_get_integer_keyed_int;
    vt->get_integer_keyed_str = Parrot_CallContext_get_integer_keyed_str;
    vt->get_number_keyed = Parrot_CallContext_get_number_keyed;
    vt->get_number_keyed_int = Parrot_CallContext_get_number_keyed_int;
    vt->get_number_keyed_str = Parrot_CallContext_get_number_keyed_str;
    vt->get_pmc = Parrot_CallContext_get_pmc;
    vt->get_pmc_keyed = Parrot_CallContext_get_pmc_keyed;
    vt->get_pmc_keyed_int = Parrot_CallContext_get_pmc_keyed_int;
    vt->get_pmc_keyed_str = Parrot_CallContext_get_pmc_keyed_str;
    vt->get_string = Parrot_CallContext_get_string;
    vt->get_string_keyed = Parrot_CallContext_get_string_keyed;
    vt->get_string_keyed_int = Parrot_CallContext_get_string_keyed_int;
    vt->get_string_keyed_str = Parrot_CallContext_get_string_keyed_str;
    vt->init = Parrot_CallContext_init;
    vt->mark = Parrot_CallContext_mark;
    vt->morph = Parrot_CallContext_morph;
    vt->push_float = Parrot_CallContext_push_float;
    vt->push_integer = Parrot_CallContext_push_integer;
    vt->push_pmc = Parrot_CallContext_push_pmc;
    vt->push_string = Parrot_CallContext_push_string;
    vt->set_attr_str = Parrot_CallContext_set_attr_str;
    vt->set_integer_keyed = Parrot_CallContext_set_integer_keyed;
    vt->set_integer_keyed_int = Parrot_CallContext_set_integer_keyed_int;
    vt->set_integer_keyed_str = Parrot_CallContext_set_integer_keyed_str;
    vt->set_number_keyed = Parrot_CallContext_set_number_keyed;
    vt->set_number_keyed_int = Parrot_CallContext_set_number_keyed_int;
    vt->set_number_keyed_str = Parrot_CallContext_set_number_keyed_str;
    vt->set_pmc = Parrot_CallContext_set_pmc;
    vt->set_pmc_keyed = Parrot_CallContext_set_pmc_keyed;
    vt->set_pmc_keyed_int = Parrot_CallContext_set_pmc_keyed_int;
    vt->set_pmc_keyed_str = Parrot_CallContext_set_pmc_keyed_str;
    vt->set_string_keyed = Parrot_CallContext_set_string_keyed;
    vt->set_string_keyed_int = Parrot_CallContext_set_string_keyed_int;
    vt->set_string_keyed_str = Parrot_CallContext_set_string_keyed_str;
    vt->set_string_native = Parrot_CallContext_set_string_native;
    vt->shift_pmc = Parrot_CallContext_shift_pmc;
    vt->shift_string = Parrot_CallContext_shift_string;
    vt->unshift_pmc = Parrot_CallContext_unshift_pmc;
    vt->attr_size = sizeof(Parrot_CallContext_attributes);

    return vt;
}


PARROT_EXPORT
VTABLE *Parrot_CallContext_ro_update_vtable(ARGMOD(VTABLE *vt)) {
    vt->clone = Parrot_CallContext_clone;
    vt->destroy = Parrot_CallContext_destroy;
    vt->elements = Parrot_CallContext_elements;
    vt->exists_keyed = Parrot_CallContext_exists_keyed;
    vt->exists_keyed_int = Parrot_CallContext_exists_keyed_int;
    vt->exists_keyed_str = Parrot_CallContext_exists_keyed_str;
    vt->get_attr_str = Parrot_CallContext_get_attr_str;
    vt->get_integer_keyed = Parrot_CallContext_get_integer_keyed;
    vt->get_integer_keyed_int = Parrot_CallContext_get_integer_keyed_int;
    vt->get_integer_keyed_str = Parrot_CallContext_get_integer_keyed_str;
    vt->get_number_keyed = Parrot_CallContext_get_number_keyed;
    vt->get_number_keyed_int = Parrot_CallContext_get_number_keyed_int;
    vt->get_number_keyed_str = Parrot_CallContext_get_number_keyed_str;
    vt->get_pmc = Parrot_CallContext_get_pmc;
    vt->get_pmc_keyed = Parrot_CallContext_get_pmc_keyed;
    vt->get_pmc_keyed_int = Parrot_CallContext_get_pmc_keyed_int;
    vt->get_pmc_keyed_str = Parrot_CallContext_get_pmc_keyed_str;
    vt->get_string = Parrot_CallContext_get_string;
    vt->get_string_keyed = Parrot_CallContext_get_string_keyed;
    vt->get_string_keyed_int = Parrot_CallContext_get_string_keyed_int;
    vt->get_string_keyed_str = Parrot_CallContext_get_string_keyed_str;
    vt->mark = Parrot_CallContext_mark;
    vt->attr_size = sizeof(Parrot_CallContext_attributes);

    return vt;
}

PARROT_EXPORT
PARROT_CANNOT_RETURN_NULL
PARROT_WARN_UNUSED_RESULT
VTABLE* Parrot_CallContext_get_vtable(PARROT_INTERP) {
    VTABLE *vt;
    vt = Parrot_default_get_vtable(interp);
    Parrot_CallContext_update_vtable(vt);

    return vt;
}

PARROT_EXPORT
PARROT_CANNOT_RETURN_NULL
PARROT_WARN_UNUSED_RESULT
VTABLE* Parrot_CallContext_ro_get_vtable(PARROT_INTERP) {
    VTABLE *vt;
    vt = Parrot_default_ro_get_vtable(interp);
    Parrot_CallContext_ro_update_vtable(vt);

    return vt;
}

PARROT_EXPORT
PARROT_CANNOT_RETURN_NULL
PARROT_WARN_UNUSED_RESULT
PMC* Parrot_CallContext_get_mro(PARROT_INTERP, ARGMOD(PMC* mro)) {
    if (PMC_IS_NULL(mro)) {
        mro = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    }

    VTABLE_unshift_string(interp, mro, CONST_STRING_GEN(interp, "CallContext"));
    return mro;
}

PARROT_EXPORT
PARROT_CANNOT_RETURN_NULL
PARROT_WARN_UNUSED_RESULT
Hash* Parrot_CallContext_get_isa(PARROT_INTERP, ARGIN_NULLOK(Hash* isa)) {
    if (isa == NULL) {
        isa = Parrot_hash_new(interp);
    }
    Parrot_hash_put(interp, isa, (void *)(CONST_STRING_GEN(interp, "CallContext")), PMCNULL);
    return isa;
}

void
Parrot_CallContext_class_init(PARROT_INTERP, int entry, int pass)
{
    static const char attr_defs [] =
        "Fcaller_ctx :registers :bp :bp_ps :n_regs_used Flex_pad Fouter_ctx Fcurrent_sub Fhandlers Fcurrent_cont Fcurrent_namespace :current_pc Fcurrent_sig :num_constants :str_constants :pmc_constants Icurrent_HLL :warns :errors :trace_flags :recursion_depth :positionals Inum_positionals Iallocated_positionals Ftype_tuple Sshort_sig Farg_flags Freturn_flags :hash Fcontinuation ";
    if (pass == 0) {
        VTABLE * const vt  = Parrot_CallContext_get_vtable(interp);
        vt->base_type      = enum_class_CallContext;
        vt->flags          = 0|VTABLE_HAS_READONLY_FLAG;
        vt->attribute_defs = attr_defs;
        interp->vtables[entry] = vt;

        vt->whoami       = CONST_STRING_GEN(interp, "CallContext");
        vt->provides_str = CONST_STRING_GEN(interp, "hash array");
        vt->isa_hash     = Parrot_CallContext_get_isa(interp, NULL);
        {
            VTABLE * const vt_ro         = Parrot_CallContext_ro_get_vtable(interp);
            vt_ro->base_type           = enum_class_CallContext;
            vt_ro->flags               = 0|VTABLE_IS_READONLY_FLAG;

            vt_ro->attribute_defs      = attr_defs;

            vt_ro->base_type           = entry;
            vt_ro->whoami              = vt->whoami;
            vt_ro->provides_str        = vt->provides_str;
            vt->ro_variant_vtable     = vt_ro;
            vt_ro->ro_variant_vtable = vt;
            vt_ro->isa_hash            = vt->isa_hash;
        }

    }
    else { /* pass */
        {
            VTABLE * const vt  = interp->vtables[entry];

            vt->mro = Parrot_CallContext_get_mro(interp, PMCNULL);

            if (vt->ro_variant_vtable)
                vt->ro_variant_vtable->mro = vt->mro;
        }

        /* set up MRO and _namespace */
        Parrot_pmc_create_mro(interp, entry);
        {
            STRING * const method_name = CONST_STRING_GEN(interp, "backtrace");
            STRING * const signature   = CONST_STRING_GEN(interp, "->");
            Parrot_interp_register_native_pcc_method_in_ns(interp, entry,
                F2DPTR(Parrot_CallContext_nci_backtrace),
                method_name, signature);
        }
        {
        }
    } /* pass */
} /* Parrot_CallContext_class_init */

#line 1681 "./src/pmc/callcontext.pmc"
 /* end pmclass */

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4 cinoptions='\:2=2' :
 */
